<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>zookeeper分布式锁</title>
    <link href="/2022/05/16/%E6%BA%90%E7%A0%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2022/05/16/%E6%BA%90%E7%A0%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis分布式锁</title>
    <link href="/2022/05/16/%E6%BA%90%E7%A0%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2022/05/16/%E6%BA%90%E7%A0%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式锁概述</title>
    <link href="/2022/05/16/%E6%BA%90%E7%A0%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/05/16/%E6%BA%90%E7%A0%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务方案</title>
    <link href="/2022/05/15/%E6%BA%90%E7%A0%81/%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/"/>
    <url>/2022/05/15/%E6%BA%90%E7%A0%81/%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单系统多数据源事务</title>
    <link href="/2022/05/15/%E6%BA%90%E7%A0%81/%E4%BA%8B%E5%8A%A1/%E5%8D%95%E7%B3%BB%E7%BB%9F%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/05/15/%E6%BA%90%E7%A0%81/%E4%BA%8B%E5%8A%A1/%E5%8D%95%E7%B3%BB%E7%BB%9F%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring tx事务</title>
    <link href="/2022/05/15/%E6%BA%90%E7%A0%81/%E4%BA%8B%E5%8A%A1/Spring-tx%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/05/15/%E6%BA%90%E7%A0%81/%E4%BA%8B%E5%8A%A1/Spring-tx%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务概述</title>
    <link href="/2022/05/15/%E6%BA%90%E7%A0%81/%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/05/15/%E6%BA%90%E7%A0%81/%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CompletableFuture</title>
    <link href="/2022/05/14/%E6%BA%90%E7%A0%81/JDK/CompletableFuture/"/>
    <url>/2022/05/14/%E6%BA%90%E7%A0%81/JDK/CompletableFuture/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2022/05/14/%E6%BA%90%E7%A0%81/JDK/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2022/05/14/%E6%BA%90%E7%A0%81/JDK/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>硬件层面的多线程</title>
    <link href="/2022/05/14/%E6%BA%90%E7%A0%81/JDK/%E7%A1%AC%E4%BB%B6%E5%B1%82%E9%9D%A2%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/05/14/%E6%BA%90%E7%A0%81/JDK/%E7%A1%AC%E4%BB%B6%E5%B1%82%E9%9D%A2%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁优化</title>
    <link href="/2022/05/14/%E6%BA%90%E7%A0%81/JDK/%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <url>/2022/05/14/%E6%BA%90%E7%A0%81/JDK/%E9%94%81%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/2022/05/14/%E6%BA%90%E7%A0%81/JDK/ThreadLocal/"/>
    <url>/2022/05/14/%E6%BA%90%E7%A0%81/JDK/ThreadLocal/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReentrantReadWriteLock</title>
    <link href="/2022/05/14/%E6%BA%90%E7%A0%81/JDK/ReentrantReadWriteLock/"/>
    <url>/2022/05/14/%E6%BA%90%E7%A0%81/JDK/ReentrantReadWriteLock/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReentrantLock</title>
    <link href="/2022/05/14/%E6%BA%90%E7%A0%81/JDK/ReentrantLock/"/>
    <url>/2022/05/14/%E6%BA%90%E7%A0%81/JDK/ReentrantLock/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Atomic类</title>
    <link href="/2022/05/14/%E6%BA%90%E7%A0%81/JDK/Atomic%E7%B1%BB/"/>
    <url>/2022/05/14/%E6%BA%90%E7%A0%81/JDK/Atomic%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>synchronized</title>
    <link href="/2022/05/14/%E6%BA%90%E7%A0%81/JDK/synchronized/"/>
    <url>/2022/05/14/%E6%BA%90%E7%A0%81/JDK/synchronized/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile</title>
    <link href="/2022/05/14/%E6%BA%90%E7%A0%81/JDK/volatile/"/>
    <url>/2022/05/14/%E6%BA%90%E7%A0%81/JDK/volatile/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程基础知识</title>
    <link href="/2022/05/14/%E6%BA%90%E7%A0%81/JDK/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/05/14/%E6%BA%90%E7%A0%81/JDK/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/2022/05/14/%E6%BA%90%E7%A0%81/JDK/%E9%9B%86%E5%90%88/"/>
    <url>/2022/05/14/%E6%BA%90%E7%A0%81/JDK/%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zuul</title>
    <link href="/2022/05/13/%E6%BA%90%E7%A0%81/zuul/zuul/"/>
    <url>/2022/05/13/%E6%BA%90%E7%A0%81/zuul/zuul/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zuul</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud时效分析</title>
    <link href="/2022/05/12/%E6%BA%90%E7%A0%81/SpringCloud/SpringCloud%E6%97%B6%E6%95%88%E5%88%86%E6%9E%90/"/>
    <url>/2022/05/12/%E6%BA%90%E7%A0%81/SpringCloud/SpringCloud%E6%97%B6%E6%95%88%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring日志体系</title>
    <link href="/2022/05/11/%E6%BA%90%E7%A0%81/Spring/Spring%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB/"/>
    <url>/2022/05/11/%E6%BA%90%E7%A0%81/Spring/Spring%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring源码环境搭建</title>
    <link href="/2022/05/11/%E6%BA%90%E7%A0%81/Spring/Spring%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/05/11/%E6%BA%90%E7%A0%81/Spring/Spring%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ribbon</title>
    <link href="/2022/05/10/%E6%BA%90%E7%A0%81/ribbon/ribbon/"/>
    <url>/2022/05/10/%E6%BA%90%E7%A0%81/ribbon/ribbon/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ribbon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hystrix</title>
    <link href="/2022/05/09/%E6%BA%90%E7%A0%81/hystrix/hystrix/"/>
    <url>/2022/05/09/%E6%BA%90%E7%A0%81/hystrix/hystrix/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hystrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>feign</title>
    <link href="/2022/05/08/%E6%BA%90%E7%A0%81/feign/feign/"/>
    <url>/2022/05/08/%E6%BA%90%E7%A0%81/feign/feign/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>feign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring整合eureka</title>
    <link href="/2022/05/07/%E6%BA%90%E7%A0%81/eureka/spring%E6%95%B4%E5%90%88eureka/"/>
    <url>/2022/05/07/%E6%BA%90%E7%A0%81/eureka/spring%E6%95%B4%E5%90%88eureka/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eureka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eureka server集群</title>
    <link href="/2022/05/07/%E6%BA%90%E7%A0%81/eureka/eureka-server%E9%9B%86%E7%BE%A4/"/>
    <url>/2022/05/07/%E6%BA%90%E7%A0%81/eureka/eureka-server%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eureka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eureka服务续约与下线机制</title>
    <link href="/2022/05/07/%E6%BA%90%E7%A0%81/eureka/eureka%E6%9C%8D%E5%8A%A1%E7%BB%AD%E7%BA%A6%E4%B8%8E%E4%B8%8B%E7%BA%BF%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/05/07/%E6%BA%90%E7%A0%81/eureka/eureka%E6%9C%8D%E5%8A%A1%E7%BB%AD%E7%BA%A6%E4%B8%8E%E4%B8%8B%E7%BA%BF%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eureka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eureka server注册表同步</title>
    <link href="/2022/05/07/%E6%BA%90%E7%A0%81/eureka/eureka-server%E5%90%8C%E6%AD%A5%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    <url>/2022/05/07/%E6%BA%90%E7%A0%81/eureka/eureka-server%E5%90%8C%E6%AD%A5%E6%B3%A8%E5%86%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eureka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eureka client</title>
    <link href="/2022/05/07/%E6%BA%90%E7%A0%81/eureka/eureka-client/"/>
    <url>/2022/05/07/%E6%BA%90%E7%A0%81/eureka/eureka-client/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eureka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eureka server</title>
    <link href="/2022/05/07/%E6%BA%90%E7%A0%81/eureka/eureka-server/"/>
    <url>/2022/05/07/%E6%BA%90%E7%A0%81/eureka/eureka-server/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eureka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eureka环境搭建与目录</title>
    <link href="/2022/05/07/%E6%BA%90%E7%A0%81/eureka/eureka%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%9B%AE%E5%BD%95/"/>
    <url>/2022/05/07/%E6%BA%90%E7%A0%81/eureka/eureka%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eureka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行为型设计模式</title>
    <link href="/2022/05/06/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/05/06/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构性设计模式</title>
    <link href="/2022/05/06/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/05/06/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建型设计模式</title>
    <link href="/2022/05/06/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/05/06/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式概述</title>
    <link href="/2022/05/06/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/05/06/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ源码</title>
    <link href="/2022/05/05/RocketMQ/RocketMQ%E6%BA%90%E7%A0%81/"/>
    <url>/2022/05/05/RocketMQ/RocketMQ%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ概述</title>
    <link href="/2022/05/05/RocketMQ/RocketMQ%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/05/05/RocketMQ/RocketMQ%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis方案</title>
    <link href="/2022/05/04/Redis/Redis%E6%96%B9%E6%A1%88/"/>
    <url>/2022/05/04/Redis/Redis%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis原理</title>
    <link href="/2022/05/04/Redis/Redis%E5%8E%9F%E7%90%86/"/>
    <url>/2022/05/04/Redis/Redis%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis进阶</title>
    <link href="/2022/05/04/Redis/Redis%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/05/04/Redis/Redis%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础</title>
    <link href="/2022/05/04/Redis/Redis%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/05/04/Redis/Redis%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/04/hello-world/"/>
    <url>/2022/05/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Hello World</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty源码与调优</title>
    <link href="/2022/05/03/Netty/Netty%E6%BA%90%E7%A0%81%E4%B8%8E%E8%B0%83%E4%BC%98/"/>
    <url>/2022/05/03/Netty/Netty%E6%BA%90%E7%A0%81%E4%B8%8E%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<p>TODO</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty进阶</title>
    <link href="/2022/05/03/Netty/Netty%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/05/03/Netty/Netty%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<p>TODO</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty入门</title>
    <link href="/2022/05/03/Netty/Netty%E5%85%A5%E9%97%A8/"/>
    <url>/2022/05/03/Netty/Netty%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>TODO</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO编程</title>
    <link href="/2022/05/03/Netty/NIO%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/05/03/Netty/NIO%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>TODO</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分库分表</title>
    <link href="/2022/05/02/MySQL/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <url>/2022/05/02/MySQL/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生产经验与案例</title>
    <link href="/2022/05/02/MySQL/%E7%94%9F%E4%BA%A7%E7%BB%8F%E9%AA%8C%E4%B8%8E%E6%A1%88%E4%BE%8B/"/>
    <url>/2022/05/02/MySQL/%E7%94%9F%E4%BA%A7%E7%BB%8F%E9%AA%8C%E4%B8%8E%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>执行计划</title>
    <link href="/2022/05/02/MySQL/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <url>/2022/05/02/MySQL/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引</title>
    <link href="/2022/05/02/MySQL/%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/05/02/MySQL/%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁机制</title>
    <link href="/2022/05/02/MySQL/%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/05/02/MySQL/%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务机制</title>
    <link href="/2022/05/02/MySQL/%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/05/02/MySQL/%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>log日志</title>
    <link href="/2022/05/02/MySQL/log%E6%97%A5%E5%BF%97/"/>
    <url>/2022/05/02/MySQL/log%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理存储</title>
    <link href="/2022/05/02/MySQL/%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8/"/>
    <url>/2022/05/02/MySQL/%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Buffer Pool</title>
    <link href="/2022/05/02/MySQL/BufferPool/"/>
    <url>/2022/05/02/MySQL/BufferPool/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL部署与扩展</title>
    <link href="/2022/05/02/MySQL/MySQL%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%89%A9%E5%B1%95/"/>
    <url>/2022/05/02/MySQL/MySQL%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL概述</title>
    <link href="/2022/05/02/MySQL/MySQL%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/05/02/MySQL/MySQL%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOM优化</title>
    <link href="/2022/05/01/JVM/OOM%E4%BC%98%E5%8C%96/"/>
    <url>/2022/05/01/JVM/OOM%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM优化</title>
    <link href="/2022/05/01/JVM/JVM%E4%BC%98%E5%8C%96/"/>
    <url>/2022/05/01/JVM/JVM%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GC与日志分析</title>
    <link href="/2022/05/01/JVM/GC%E4%B8%8E%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    <url>/2022/05/01/JVM/GC%E4%B8%8E%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收</title>
    <link href="/2022/05/01/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2022/05/01/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收细节"><a href="#垃圾回收细节" class="headerlink" title="垃圾回收细节"></a>垃圾回收细节</h1><h2 id="什么时候触发垃圾回收"><a href="#什么时候触发垃圾回收" class="headerlink" title="什么时候触发垃圾回收"></a>什么时候触发垃圾回收</h2><p>随着系统的运行，当新生代里的对象越来越多，快满了的时候，触发垃圾回收，将新生代里没人引用的对象回收掉，释放内存空间。</p><h2 id="哪些变量引用不能回收"><a href="#哪些变量引用不能回收" class="headerlink" title="哪些变量引用不能回收"></a>哪些变量引用不能回收</h2><p>JVM使用可达性分析算法判断哪些对象可以被回收哪些不能回收。<br>可达性分析算法：对每个对象，都分析一下有谁在引用他，一层层往上判断，是否有一个GC Roots。<br>GC Roots</p><ul><li>方法的局部变量</li><li>类的静态变量</li></ul><h2 id="对象的引用类型"><a href="#对象的引用类型" class="headerlink" title="对象的引用类型"></a>对象的引用类型</h2><ul><li>强引用</li></ul><p>一个变量引用一个对象，只要是强引用的类型，那么垃圾回收绝对不会回收这个对象</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Kafka</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReplicaManager</span> <span class="hljs-variable">rm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReplicaManager</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>软引用</li></ul><p>正常情况下垃圾回收是不会回收软引用对象，但是如果进行垃圾回收之后，发现内存空间还是不够存放新的对象，内存都快溢出了。就会把这些软引用对象给回收掉，哪怕他被变量引用了，但是因为是软引用，所以还是会回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Kafka</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SoftReference&lt;ReplicaManager&gt; rm = <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;ReplicaManager&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReplicaManager</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>ReplicaManager实例对象用<code>SoftReference</code>软引用类型的对象包裹起来，此时rm变量对ReplicaManager对象的引用就是软引用。<br>软引用对象在GC的时候是否回收存在公式：clock - timestamp &lt;&#x3D; freespace * SortRTefLRUPolicyMSPerMB<br>clock - timestamp：软引用对象多久没有被访问过了<br>freespace：JVM中空闲内存空间<br>SortRTefLRUPolicyMSPerMB：每1MB口你想空间允许SoftReference对象存活多久<br>假如JVM空闲空间为3000MB，SortRTefLRUPolicyMSPerMB默认1000毫秒，那么存活时间为3000*1000 &#x3D; 3000秒。</p><ul><li>弱引用</li></ul><p>弱引用就和没有引用类似，如果发生垃圾回收，就会将整个对象回收掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Kafka</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WeakReference&lt;ReplicaManager&gt; rm = <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;ReplicaManager&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReplicaManager</span>());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>虚引用</li></ul><h2 id="Object-finalize"><a href="#Object-finalize" class="headerlink" title="Object.finalize()"></a>Object.finalize()</h2><p>假如要被垃圾回收的对象，重写了Object的finalize()方法。<br>那么在垃圾回收之前，会先尝试调用一下他的finalize()方法，看是否把自己的这个实例对象给某个GC Roots变量。如果重新让某个GC Roots变量引用了自己，那么就不用被垃圾回收了。</p><h2 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop the World"></a>Stop the World</h2><p>在垃圾回收的时候，尽可能让垃圾回收器专心致志的工作，不能随便让Java程序继续写对象。此时JVM后台会进入<code>Stop the World</code>状态，直接停止Java系统的所有工作线程，等垃圾回收完再运行。<br>不同的垃圾回收器针对<code>Stop the World</code>状态，进行了优化。需要合理的对线程系统优化内存分配和垃圾回收，尽量减少垃圾回收的频率，降低垃圾回收的时间，减少垃圾回收对系统运行的影响。</p><h2 id="触发老年代Full-GC的时机"><a href="#触发老年代Full-GC的时机" class="headerlink" title="触发老年代Full GC的时机"></a>触发老年代Full GC的时机</h2><ol><li>老年代可用内存小于新生代全部对象的大小，如果没有开启空间担保参数，会直接触发Full GC</li><li>老年代可用内存小于历次新生代GC后进入老年代的平均对象大小，会触发Full GC</li><li>新生代Minor GC后的存活对象大于Survivor，那么会进入老年代，此时老年代内存不足，会触发Full GC</li><li><code>-XX:CMSInitiatingOccupancyFaction</code>参数设置比例，老年代可用内存空间大于历次新生代GC后进入老年代已经使用的内存空间超过了这个参数指定的比例，会触发Full GC</li></ol><h2 id="合理的GC频率"><a href="#合理的GC频率" class="headerlink" title="合理的GC频率"></a>合理的GC频率</h2><p>一次minor gc间隔10s以上，每次不超过50ms<br>full gc间隔十分钟以上一次，每次不超过1s</p><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="复制算法-新生代垃圾回收算法"><a href="#复制算法-新生代垃圾回收算法" class="headerlink" title="复制算法-新生代垃圾回收算法"></a>复制算法-新生代垃圾回收算法</h2><p>针对新生代的垃圾回收算法，叫做复制算法。</p><h3 id="区域划分"><a href="#区域划分" class="headerlink" title="区域划分"></a>区域划分</h3><p>1个Eden区，2个Survivor区<br>其中Eden区占80%的内存空间，每一块Survivor区各占10%内存空间。<br>平时使用Eden区+其中一块Survivor区<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12966419/1650357555914-4869f94b-df21-48b5-b8b4-a8efdaaee89e.png#clientId=ufb7092a7-0f3d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=340&id=u03b15cf4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=340&originWidth=614&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17098&status=done&style=none&taskId=ue8c1bc90-aa5c-4f79-a4a8-25a4692fb96&title=&width=614" alt="image.png"></p><h3 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h3><ol><li>最开始对象都分配在Eden区内，如果Eden区快满了，就会触发垃圾回收</li><li>将Eden区中存活的对象都一次性转移到一块空着的Survivor区。然后Eden区就会清空，然后再次分配新对象到Eden区里。Eden区和一块Survivor区里存在对象，其中Survivor区里放的是上一次Minor GC之后存活的对象。</li><li>如果下一次Eden再次满了，那么再次触发Minor GC，会将Eden区和放着上次Minor GC后存活对象的Survivor区的存活对象，转移到另一块Survivor区去。</li></ol><p>复制算法始终保持一块Survivor区域空着，循环使用三块区域。最大的好处是只有10%的内存闲置。</p><h2 id="标记整理算法-老年代垃圾回收算法"><a href="#标记整理算法-老年代垃圾回收算法" class="headerlink" title="标记整理算法-老年代垃圾回收算法"></a>标记整理算法-老年代垃圾回收算法</h2><p>老年代进行垃圾回收的算法</p><h3 id="进入老年代的时机"><a href="#进入老年代的时机" class="headerlink" title="进入老年代的时机"></a>进入老年代的时机</h3><ol><li>达到一定岁数进入老年代</li></ol><p>在默认设置下，当对象的年龄达到15岁的时候，会转移到老年代中。<br>可以通过<code>-XX:MaxTenuringThreshold</code>修改设置，默认15岁。</p><ol start="2"><li>动态年龄判断</li></ol><p>假如当前放对象的Survivor区域里，一批对象的中大小大于了这块Survivor区域内存大小的50%，那么此时，大于等于这批对象年龄的对象，可以直接进入老年代</p><blockquote><p>年龄1+年龄2+….+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n以上的对象都放入老年代。</p></blockquote><p>动态年龄判断的规则，会让一些新生代的对象也进入老年代。</p><ol start="3"><li>大对象直接进入老年代</li></ol><p><code>-XX:PretenureSizeThreshold</code>可以将他的值设置为字节数，比如1048576字节，就是1MB。<br>意思就是如果要创建一个大于这个大小的对象，比如一个超大的数组，或者别的东西，此时就会直接把这个大对象放到老年代去，不会经过新生代。</p><p>注意<br>1和2是将长期存活的对象，放入老年代。<br>3是避免大对象在内存间来回复制，耗费时间。</p><h3 id="特殊场景"><a href="#特殊场景" class="headerlink" title="特殊场景"></a>特殊场景</h3><ul><li>Minor GC后的对象太多无法放入Survivor区</li></ul><p>这个时候必须将这些对象直接转移到老年代去。</p><h3 id="老年代空间分配担保规则"><a href="#老年代空间分配担保规则" class="headerlink" title="老年代空间分配担保规则"></a>老年代空间分配担保规则</h3><p>在执行任何一次Minor GC之前，JVM会先检查一遍老年代可用的可用内存空间是否大于新生代所有对象的总大小。</p><ol><li>在极端情况下，经过一次Minor GC，所有对象都会存活下来，即所有新生代对象都可以进入老年代。</li><li>假如在Minor GC之前，发现老年代的可用内存已经小于新生代的全部对象大小了，就会检查<code>-XX:-HandlePromotionFailure</code>参数是否设置。</li><li>如果这个参数，就会判断老年代内存大小是否大于之前每一次Minor GC后进入老年代对象的平均大小。(如果之前每次Minor GC每次活下来10MB，那么此时老年代内存如果大于10MB，那么很可能就是够用的)</li></ol><ul><li>如果步骤3执行失败或者步骤2没有设置参数，那么就会直接出发一次<code>Full GC</code>对老年代进行垃圾回收</li><li>如果步骤2参数设置了并且步骤3判断成功了，那么可以进行尝试Minor GC<ul><li>Minor GC后，剩余的存活对象的大小，小于Survivor区域的大小，那么此时存活对象进入Survivor区域</li><li>Minor GC后，剩余的存活对象的大小，大于Survivor区域大小，但是小于老年代可用内存大小，那么直接进入老年代</li><li>Minor GC后，剩余的存活对象的大小，大于Survivor区域大小，也大于老年代可用内存大小，就会发生<code>Handle Promotion Failure</code>触发<code>Full GC</code></li></ul></li></ul><ol start="4"><li>如果Full GC之后，老年代还是没有足够的内存存放Minor GC过后的剩余存活对象，就会导致OOM内存溢出</li></ol><blockquote><p><code>-XX:-HandlePromotionFailure</code>参数在JDK1.6走后废弃，不需要进行设置。</p></blockquote><h3 id="回收流程-1"><a href="#回收流程-1" class="headerlink" title="回收流程"></a>回收流程</h3><ol><li>首先标记出老年代当前存活的对象，这些对象可能会比较分散</li><li>让这些存活对象在内存里面进行移动，把存活对象尽量都挪动到一边去，让存活对象紧凑的靠在一起，避免垃圾回收过后出现过多的内存碎片</li><li>一次性将垃圾对象回收掉</li></ol><p>注意：Full GC的速度至少比Minor GC慢10倍</p><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>Serial和Serial Old垃圾回收器</li></ul><p>分别用来回收新生代和老年代的垃圾对象<br>工作原理就是单线程运行，垃圾回收的时候，会停止我们自己写的系统的其他工作线程，让系统卡死，然后等他们垃圾回收。现在一般Java后台系统几乎不用。</p><ul><li>ParNew和CMS垃圾回收器</li></ul><p>ParNew现在一般都是在新生代的垃圾回收器，CMS是用在老年代的垃圾回收器。他们都是多线程并发机制，性能更好，现在一般是线上生产系统的标配</p><ul><li>G1垃圾回收器</li></ul><p>统一收集新生代和老年代，采用了更加优秀的算法和设计机制</p><h2 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>新生代ParNew垃圾回收器主打的就是多线程垃回收机制。而Serial垃圾回收器主打的是单线程垃圾回收，他们都是回收新生代，除了单线程和多线程的区别，垃圾回收算法是完全一样的。</p><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><ul><li>指定使用ParNew垃圾回收器</li></ul><p><code>-XX:+UseParNewGC</code></p><ul><li>线程数分配</li></ul><p>一般根据CPU核数决定，不需要手动调节。<br>手动指定使用<code>-XX:parallelGCThreads</code></p><ul><li>使用ParNew还是Serial</li></ul><p>一般根据服务类型（server&#x2F;client）决定。linux部署的server一般使用ParNew。但是windows本地客户端很多时候使用Serial，减少线程上下文切换的开销。</p><h2 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>CMS垃圾回收器负责回收老年代，采用标记-清理算法。由于<code>Stop the World</code>的存在，如果采用<code>标记-清理</code>算法执行，直接停止工作线程，会导致系统卡死时间过长。所以CMS垃圾回收器采用的是垃圾回收线程和系统工作线程尽量同时执行的模式进行处理。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>CMS执行一次垃圾回收的过程分为4个阶段</p><ol><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清理</li></ol><p><strong>第一个阶段：初始标记</strong><br>首先CMS要进行垃圾回收时，会先执行初始标记阶段，这个阶段让系统的工作线程全部停止，进入<code>Stop the World</code>状态。<br>初始标记，就是标记出所有GC Roots直接引用的对象。</p><p><strong>第二个阶段：并发标记</strong><br>这个阶段会让系统线程可以随意创建各种新对象，继续运行。<br>在运行期间可能会创建新的存活对象，也可能会让部分存活对象失去引用，变成垃圾对象。在这个过程中，垃圾回收线程会尽可能对已有的对象进行GC Roots追踪。</p><blockquote><p>GC Roots追踪：用可达性分析，一层层往上看对象是否存在GC Roots。</p></blockquote><p>这个阶段就是对老年代所有对象进行GC Roots追踪，耗时最久。他需要追踪所有对象是否从根源上被GC Roots引用，是和系统程序并发运行的，所以不会对系统运行造成影响。</p><p><strong>第三个阶段：重新标记</strong><br>由于第二个阶段是和系统并发运行，所以会有很多新对象创建，也会有老对象变成垃圾对象。<br>第三个阶段会让系统进入<code>Stop the World</code>，重新标记在第二阶段里重新创建的一些对象，还有一些已有对象可能失去引用变成垃圾的情况。<br>这个阶段速度也很快，就是对第二阶段中被系统程序运行变动过的少数对象进行标记，所以运行速度很快。</p><p><strong>第四个阶段：并发清理</strong><br>这个阶段就是让系统随意运行，然后清理掉之前标记为垃圾的对象。<br>这个阶段也比较耗时，但是与系统并行运行，所以不会对系统运行造成影响。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li>占用CPU资源</li></ol><p>在垃圾回收的同时让系统工作，并且这两个步骤的垃圾回收耗时比较久，会比较耗费CPU资源。<br>CMS默认启动的垃圾回收线程数是(CPU核数+ 3) &#x2F; 4</p><ol start="2"><li>Concurrent Mode Failure</li></ol><p>在并发清理阶段，CMS只是回收之前标记好的垃圾，但是此时系统同时也在运行，也会产生新的垃圾。这种垃圾叫做<code>浮动垃圾</code>。<br>浮动垃圾只能在下一次Full GC的时候回收。为了保证垃圾回收期间的浮动垃圾正常产生，会进行空间预留。<br><code>-XX:CMSInitiatingOccupancyFaction</code>可以设置老年代占用多少比例的时候触发CMS垃圾回收，默认92%<br>如果CMS垃圾回收期间，系统进入老年代的对象大于可用空间，会发生<code>Concurrent Mode Failure</code>垃圾回收失败。此时会自动使用<code>Serial Old</code>垃圾回收期代替CMS，强行把系统程序<code>Stop the world</code>，重新进行长时间的GC Roots追踪，标记出来全部垃圾对象，不允许新的对象产生。然后一次性把垃圾对象都回收掉，最后再回复系统线程。</p><ol start="3"><li>内存碎片问题</li></ol><p>如果内存碎片太多，会导致后续对象进入老年代找不到可用的连续内存空间，然后出发Full GC。<br>CMS不是完全就仅仅使用<code>标记-清理</code>算法，太多的内存碎片会导致更加频繁的Full GC。<br><code>-XX:+UseCMSCompactAtFullConllection</code>默认打开，表示在Full GC之后，再次进行<code>Stop the World</code>，停止工作线程，然后进行碎片整理，把存活对象挪到一起，空出来大片连续内存空间，避免内存碎片。<br><code>-XX:CMSFullGCsBeforeCompaction</code>，表示执行多少次Full GC之后再执行一次内存碎片整理工作，默认是0，表示每次执行后都会进行内存整理。</p><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><h3 id="ParNew-CMS的缺点"><a href="#ParNew-CMS的缺点" class="headerlink" title="ParNew+CMS的缺点"></a>ParNew+CMS的缺点</h3><p><code>Stop the World</code>无论是新生代还是老年代都会存在STW现象，对系统运行有一定影响。<br>垃圾回收器的优化就是朝着减少STW的目标进行。</p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><ol><li>G1垃圾回收器可以同时回收新生代和老年代的对象。</li><li>把Java堆内存拆分为多个大小相等的Region。</li></ol><p>G1也存在新生代和老年代的概念，但是只是逻辑上的概念，也就是新生代包含某部分Region，老年代包含某些Region。</p><ol start="3"><li>G1可以让我们设置一个垃圾回收的预期停顿时间。</li></ol><p>G1必须追踪每个Region里面的回收价值。他需要搞清楚每个Region里的对象有多少是垃圾，如果对这个Region进行垃圾回收，需要耗费多长时间，可以回收多少垃圾。</p><p>G1可以做到让你设定垃圾回收对系统的影响，通过将内存拆分为大量小Region，以及追踪每个Region中可以回收的对象大小和预估时间，最后再垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在指定时间范围内，同时在有限的时间内回收尽可能多的垃圾对象。<br>在G1中没有所谓的新生代多少内存，老年代多少内存。Region的区域分配会不停变动，由G1自动控制。</p><h3 id="工作细节"><a href="#工作细节" class="headerlink" title="工作细节"></a>工作细节</h3><ol><li>设定G1对应内存大小</li></ol><p>默认情况下自动计算和设置，可以给整个堆内存的大小，然后JVM启动的时候发现是G1垃圾回收器(使用<code>-XX:UseG1GC</code>指定使用G1垃圾回收器)，此时自动用堆大小除以2048。<br>因为JVM最多可以有2048个Region。然后Region大小必须是2的倍数，比如1MB,2MB,4MB。</p><ul><li>–XX:G1HeapRegionSize</li></ul><p>手动指定Region大小</p><ol start="2"><li>G1是否存在原本的分区</li></ol><p>G1依旧存在原本的新生代和老年代分区。<br>新生代分区划分为Eden和Survivor。依旧使用原本的参数调整占比。只是Region是动态划分。</p><ul><li>–XX:G1NewSizePercent</li></ul><p>刚开始，默认新生代堆内存的占比是5%。可以使用这个设置新生代初始占比</p><ul><li>–XX:G1MaxNewSizePercent</li></ul><p>在运行中，JVM不停的给新生代增加更多的Region，但是最多新生代占比不会超过60%。可以通过这个设置新生代最大占比</p><ol start="3"><li><p>G1的新生代垃圾回收</p><ol><li>随着不听的在新生代的Eden对应的Region中放对象，JVM就会不停地给新生代加入更多的Region</li><li>当新生代达到堆内存的最大大小60%，其中Eden区占用80%即1000个Region，Survivor每个占用100个Region。并且Eden区占满对象，会触发新生代GC</li><li>G1使用复制算法进行垃圾回收，并且进入<code>Stop the World</code>状态</li><li>将Eden区对应Region存活对象放入S1对应Region区，然后回收掉Eden区对应的Region中的垃圾对象</li><li>由于G1可以设定GC停顿时间<code>-XX:MAXGCPauseMills</code>，因此在上面基础上，G1会保证GC停顿时间控制在指定范围内，尽可能多的回收掉一些对象</li></ol></li><li><p>对象进入老年代的时机</p></li></ol><p>与原先一致：</p><ul><li>对象在新生代躲过了很多次垃圾回收，达到一定年龄</li><li>动态年龄判定规则</li></ul><p>与原本区别</p><ul><li>大对象</li></ul><p>G1提供了专门的Region存放大对象，而不是让大对象进入老年代的Region中。<br>G1中，大对象的判定规则就是一个大对象超过了一个Region的50%，就会放入大对象专门的Region中<br>如果一个对象太大，会横跨多个Region存放。<br>大对象的回收，会在新生代、老年代回收的时候，顺带着大对象Region一起回收。</p><ol start="5"><li>新生代+老年代的混合垃圾回收</li></ol><p><code>-XX:InitiatingHeapOccupancyPercent</code>如果来年代占据了堆内存45%的Region的时候，会尝试触发一个新生代+老年代一起的混合回收阶段。默认值为45%</p><p><strong>初始标记</strong><br>首先触发初始标记，这个过程需要进入STW，仅仅进行标记。<br>先停止系统的运行，然后对各个线程栈内存中的局部变量代表的GC Roots，以及方法区中的静态变量代表的GC Roots，进行扫描，标记他们直接引用的那些对象。</p><p><strong>并发标记</strong><br>然后进入并发标记，这个阶段允许系统程序运行，同时进行GC Roots跟踪，从GC Roots开始追踪所有的存活对象。<br>JVM会对并发标记阶段对对象作出的一些修改记录起来，比如哪个对象被新建了，哪个对象失去了引用。</p><p><strong>最终标记</strong><br>然后进入最终标记，这个过程需要进入STW，系统禁止运行，但是会根据并发标记阶段的记录，去最终标记哪些存活对象，哪些是垃圾对象。</p><p><strong>混合回收</strong><br>最后进入混合回收，这个阶段会计算老年代中每个Region中存活对象数量，存活对象的占比，还有执行垃圾回收的预期性能和效率。<br>然后停止系统，去全力进行垃圾回收。为了保证停顿时间在控制范围内，会选择部分Region进行回收。</p><ol start="6"><li>回收失败的Full GC</li></ol><p>在进行Mixed回收的时候，无论年轻代还是老年代都基于复制算法进行回收，需要把各个Region的存活对象拷贝到别的Region中。<br>要是拷贝过程中，发现没有空闲的Region可以承载存活对象，就会触发一次失败。<br>失败后，会立刻切换为停止系统程序，然后采用单线程进行标记，清理和压缩整理，空闲出一批Region。</p><h3 id="G1垃圾回收器的一些参数"><a href="#G1垃圾回收器的一些参数" class="headerlink" title="G1垃圾回收器的一些参数"></a>G1垃圾回收器的一些参数</h3><ul><li>-XX:G!MixedGCCountTarget</li></ul><p>在一次混合回收中，最后一个阶段执行几次混合回收。默认8次。<br>意味着最后一个阶段，先停止系统运行，混合回收一些Region，再恢复系统运行，接着再禁止系统运行，混合回收一些Region，反复8次。<br>如果一次混合回收预期要回收160Region，那么每次混合回收会回收20个Region。<br>多次混合回收，为了尽可能让系统不要停顿时间过长。</p><ul><li>-XX:G1HeapWastePercent</li></ul><p>默认5%<br>在混合回收的时候，对Region回收都是基于复制算法进行的，都要把回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理。这样子在回收过程中会不断空出来新的Region，一旦空闲的Region数量，打到堆内存的5%,就会停止混合回收。</p><ul><li>-XX:G1MixedGCLiveThresholdPercent</li></ul><p>默认值85%<br>确定要回收的Region的时候，必须是存活对象低于85%的Region才进行回收。<br>因为大对象的拷贝成本比较高。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM案例</title>
    <link href="/2022/05/01/JVM/JVM%E6%A1%88%E4%BE%8B/"/>
    <url>/2022/05/01/JVM/JVM%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="每日百万交易的支付系统"><a href="#每日百万交易的支付系统" class="headerlink" title="每日百万交易的支付系统"></a>每日百万交易的支付系统</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12966419/1650352307495-849c668f-8a5e-492c-ab58-059818bfe0a6.png#clientId=u0981b04d-1a44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=318&id=uc2f9b2f3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=318&originWidth=625&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13955&status=done&style=none&taskId=u9f40696b-5162-45c5-8092-ce6d60ba638&title=&width=625" alt="image.png"></p><h2 id="瓶颈分析"><a href="#瓶颈分析" class="headerlink" title="瓶颈分析"></a>瓶颈分析</h2><p>每天JVM会频繁的创建和销毁100W个支付订单。</p><ol><li>估算每秒需要处理多少订单</li></ol><p>假设每天100W个字符订单，用户交易行为发生在高峰期。假设高峰期每天几个小时，用100w平均分配到高峰期里，估算TPS，大概为每秒100笔订单。<br>假设支付系统集群部署3个机器，所以每个机器实际每秒处理30笔订单。</p><ol start="2"><li>估算每个订单处理耗时</li></ol><p>按照上面的假设，需要TPS30来算，内存中每秒至少存在30个订单的对象。</p><ol start="3"><li>估算支付订单需要多大的内存空间</li></ol><p>可以按照订单对象存在多少变量，按变量占用字节数估算。实际还有其他东西会比估算的大。可以测试环境打印一个看看。</p><ol start="4"><li>每秒发起的支付请求对内存的占用</li></ol><p>30个支付订单，大概占用内存空间30*500字节&#x3D;15000字节，大概15kb</p><ol start="5"><li>支付系统运行情况下分析</li></ol><p>每秒30个支付请求，创建30个支付订单对象，kb级别的占用。<br>下一秒又产生30个支付订单对象。<br>等到新生代里面存在几十万个对象的时候，大概占用几百MB，新生代就满了，需要进行一次Minor GC，将新生代里面的垃圾对象回收掉，腾出空间。</p><ol start="6"><li>对完整系统内存占用预估</li></ol><p>除了核心流程的对象占用，实际上还会存在其他对象。根据系统压力，姑且按照之前计算结果的10-20倍估算。</p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>一般线上业务系统的机器配置为2核4G，或者4核8G。</p><p>假如使用2核4G的机器，除去机器自身占用内存，大概剩下2G给JVM进程，按照方法区，栈内存，堆内存划分完，堆内存大概分配到1G的内存空间。<br>然后堆内存分为新生代和老年代，划分完也就几百MB。<br>按照上面的业务模型，大概几百秒触发一次Minor GC，太频繁了。</p><p>因此按照4核8G的机器分配。<br>-Xms和-Xmx设置为3G<br>-Xmn设置为2G</p><h1 id="日处理上亿数据的计算系统"><a href="#日处理上亿数据的计算系统" class="headerlink" title="日处理上亿数据的计算系统"></a>日处理上亿数据的计算系统</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12966419/1650419797784-202769e8-1cf6-4c5c-8b8f-e7f3b47a6072.png#clientId=u08968c11-d05f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=228&id=u9d942e3f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=228&originWidth=262&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6664&status=done&style=none&taskId=u9eb1c519-8a1e-4d2c-8678-3073ceec095&title=&width=262" alt="image.png"><br>计算系统不同的通过sql和其他方式从数据存储中提取数据到内存中计算，生产负载大概是每分钟执行500次数据提取和计算任务。<br>在部署多台机器的情况下，每台机器每分钟大概负责执行100次数据提取和计算任务。<br>每次提取大概1W左右的数据到内存计算，平均每次计算大概需要10s左右。<br>每台机器的配置为4核8G，JVM内存占用4G，其中新生代和老年代分别占用1.5G内存。</p><h2 id="瓶颈分析-1"><a href="#瓶颈分析-1" class="headerlink" title="瓶颈分析"></a>瓶颈分析</h2><ol><li>系统多快会塞满新生代？</li></ol><p>每条数据大概20个字段，大概每条数据在1KB大小，那么每次计算任务超过1W条就对应了10MB大小。<br>新生代按默认8：1：1进行分配的话，Eden区1.2GB，每块Survivor区在100MB左右。<br>按上面的分析，每分钟100次计算差不多1分钟之后Eden区就满了。</p><ol start="2"><li>触发Minor GC的时候有多少对象进入老年代？</li></ol><p>假如新生代的Eden区1分钟之后就塞满对象，继续执行任务时触发Minor GC。<br>执行Minor GC前，会进行检查。首先看老年代的可用内存空间是否大于新生代全部对象。目前老年嗲1.5GB，新生代Eden区总共1.2GB，所以放得下。就会直接执行Minor GC。<br>此时每个计算任务1万条数据需要计算10秒，每分钟执行100个。假设还剩下20个计算任务，大概就是还剩下200MB对象存活。由于Survivor区只有100MB放不下200MB对象，因此会全部进入老年代。</p><ol start="3"><li>系统运行多久，老年代大概会填满？</li></ol><p>按照1分钟进行一次Minor GC，200MB对象进入老年代，老年代大小1.5GB。那么在7分钟左右，老年代剩余空间就剩下100MB。</p><ol start="4"><li>系统运行多久，老年代会触发1次Full GC？</li></ol><p>第8分钟结束的时候，触发Minor GC，生成200MB垃圾，发现老年代只有100MB空间，比之前每次Minor GC进入老年代的200MB都要小，就会直接触发一次Full GC。</p><h2 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h2><p>这个系统是数据计算系统，每次执行Minor GC的时候，会有一批数据没有计算完。按照现有的内存模型，瓶颈就是每次Survivor区域放不下存活对象。</p><p>优化后，新增新生代的内存比例，3GB左右的堆内存，其中2GB分配给新生代，1GB留给老年代。<br>这样Survivor区大概就是200MB，每次刚好放得下Minor GC过后存活的对象。<br>还可以调整<code>-XX:SurvivorRatio=8</code>这个参数，默认是Eden区比例为80%,在内存有限的情况下，可以降低Eden区比例，给Survivor更多内存空间。</p><h1 id="每日上亿请求量的电商系统"><a href="#每日上亿请求量的电商系统" class="headerlink" title="每日上亿请求量的电商系统"></a>每日上亿请求量的电商系统</h1><h2 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h2><p>如果请求量上亿的话，按一个用户平均20次访问计算，大概需要500w日活。<br>按照10%付费转化率计算，每天大概有50W人会下单，那么大概就是每天会有50W订单。<br>按照28法则，算订单集中在每天的4小时高峰内，平均下来每秒大概几十个订单。<br>但是在双十一等电商节的情况下，可能10分钟内就有50W订单，此时每秒接近1000个订单。<br>因此，按3台3核8G的机器计算，每秒每个机器抗300-400个请求没有压力。针对这种场景，需要对JVM有限的内存资源进行合理的分配和优化，包括对垃圾回收进行合理的优化，让JVM的GC次数尽可能减少，尽量避免Full GC，减少JVM的GC对高峰期系统的影响。</p><h2 id="年轻代垃圾回收参数优化"><a href="#年轻代垃圾回收参数优化" class="headerlink" title="年轻代垃圾回收参数优化"></a>年轻代垃圾回收参数优化</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ol><li>大促高峰期内存使用模型估算</li></ol><p>按照每秒处理300个下单请求估算。每个订单按照1KB估算，单300个订单会存在300kb的内存开销。然后算上订单对象连带的订单条目、库存、促销、优惠券等业务对象，一般单个对象开销放大10-20倍。<br>同时除了下单本身，还会存在订单查询等操作，再扩大10倍。<br>每秒钟大概300KB<em>20</em>10 &#x3D; 60MB的内存开销。过一秒之后，可以认为存在60mb的对象垃圾。</p><ol start="2"><li>内存如何分配</li></ol><p>如果是4核8G的机器，JVM内存一般给到4G，剩余的留给操作系统。<br>其中堆内存3G，新生代1.5G，老年代1.5G。<br>每个线程的Java虚拟机栈有1M，那么如果存在几百个线程大概会占用几百M<br>永久代给256M</p><ol start="3"><li>运行内存分析</li></ol><p>按照8:1:1分区，Eden区占据1.2GB，Survivor每个占用150MB。<br>订单系统每秒处理300个订单，占用新生代60MB空间。过1秒之后，60MB对象会变成垃圾，新生代1.5G内存空间大概需要20S占满。<br>20秒过后，进行Minor GC，进行前置检查比较老年代可用空间大小和历次Minor GC后进入老年代对象的平均大小。<br>Minor GC第一次运行，回收绝大部分新生代对象，除了还在请求处理中的订单，大部分订单处理完成，此时存活对象可能100MB左右，放入S1区域<br>又过了20S，Eden区满了之后，进行Minor GC，将Eden区和S1区的对象清除，剩余对象转入S2区域。</p><ol start="4"><li>Survivor空间判断</li></ol><p>Survivor空间大小毕竟是估算的，可能会存在上下波动。<br>根据动态年龄判断，如果每次都是超过50%并且是同龄对象，也会导致对象进入老年代。<br>需要调整新生代和老年代的大小。普通的业务系统，大部分对象都是短生命周期，不应该频繁进入老年代。也没必要给老年代维持过大的内存空间，首先让对象尽量留在新生代。<br>将新生代调整为2G,老年代1G。此时Eden区1.6G，每个Survivor200MB。</p><ol start="5"><li>新生代多少年龄进入老年代</li></ol><p>对于业务系统，使用默认就行了。业务系统一般进入老年代都是Spring管理的对象。<br>这个参数需要根据业务内存运行流程判断是否更改。</p><ol start="6"><li>多大的对象直接进入老年代</li></ol><p>一般设置1MB就行了，很少存在超过1MB的大对象。</p><h3 id="最终参数"><a href="#最终参数" class="headerlink" title="最终参数"></a>最终参数</h3><p>-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize&#x3D;256M -XX:MaxPermSize&#x3D;256M  -XX:SurvivorRatio&#x3D;8 -XX:MaxTenuringThreshold&#x3D;5 -XX:PretenureSizeThreshold&#x3D;1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC</p><h2 id="老年代垃圾回收参数优化"><a href="#老年代垃圾回收参数优化" class="headerlink" title="老年代垃圾回收参数优化"></a>老年代垃圾回收参数优化</h2><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><ol><li>什么情况下会让一些对象进入老年代</li></ol><ul><li><code>-XX:MaxTenuringThreshold=5</code>这个参数会让几分钟内连续躲过5次Minor GC的对象迅速进入老年代。</li><li>大对象，比如一个大数组或者大List。这种情况案例不存在，忽略</li><li>Minor GC之后可能存活对象超过200MB，放不下Survivor区域，或者一下子占用Survivor超过50%.</li></ul><ol start="2"><li>多久时间触发一次Full GC</li></ol><p>按照上面分析，可能系统运行半小时-1小时之后，才有接近1GB的对象进入老年区，才可能满足触发Full GC的条件。<br>这个时间段已经超过了大促时间，并且日常使用比这个时间更久。</p><h3 id="最终参数-1"><a href="#最终参数-1" class="headerlink" title="最终参数"></a>最终参数</h3><p>-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize&#x3D;256M -XX:MaxPermSize&#x3D;256M  -XX:SurvivorRatio&#x3D;8 -XX:MaxTenuringThreshold&#x3D;5 -XX:PretenureSizeThreshold&#x3D;1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction&#x3D;92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction&#x3D;0</p><h1 id="百万级用户的在线教育平台"><a href="#百万级用户的在线教育平台" class="headerlink" title="百万级用户的在线教育平台"></a>百万级用户的在线教育平台</h1><h2 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h2><p>百万级用户的在想教育平台，主要目标用户群体是几岁到十几岁的小孩，注册用户几百万规模，日活用户规模在几十万。<br>上课的高峰阶段在每天晚上几个小时内，以及周末，核心业务大概就是视频课程中的交互。<br>预估晚上高峰3小时内，总共60W活跃用户，每个用户大概上一小时课程。那么每小时大概20W用户同时在线。20W活跃用户大概每分钟进行一次交互，一小时进行60次。一小时内总计1200W吃交互动作，平均每秒3000次。<br>3000次并发，按每台4核8G的机器抗600次请求计算，需要5台机器。<br> 每次互动请求，大概会连带创建对象，占用几KB，当成5KB预估，每秒600请求，会占用3MB内存。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM概述</title>
    <link href="/2022/05/01/JVM/JVM%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/05/01/JVM/JVM%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><h2 id="JVM运行流程"><a href="#JVM运行流程" class="headerlink" title="JVM运行流程"></a>JVM运行流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/12966419/1650332103295-2c92eb96-a9a4-44da-ac1d-a87222be02ef.jpeg"></p><ol><li>将.java文件编译为.class字节码文件</li><li>类加载器将.class字节码文件中的类加载到JVM中</li><li>JVM执行写好的类中的代码</li></ol><h2 id="类加载流程"><a href="#类加载流程" class="headerlink" title="类加载流程"></a>类加载流程</h2><ul><li>加载</li><li>验证</li><li>准备</li><li>解析</li><li>初始化</li><li>使用</li><li>卸载<h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3>当代码里需要使用到这个类的时候，就需要加载</li></ul><h3 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h3><p>根据Java虚拟机规范，校验加载进来的.class文件的内容是否符合指定的归档</p><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>给类分配内存空间，然后给里面的变量(static修饰的变量)分配内存空间，赋值默认的初始值</p><h3 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h3><p>将符号引用替换为直接引用的过程</p><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>变量实际初始化的过程。</p><p><strong>初始化的规则</strong></p><ul><li>如果初始化一个类的时候，发现他的父类还没有初始化，就必须先初始化他的父类</li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类加载从出发到初始化需要依靠类加载器实现。</p><h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><ul><li>启动类加载器 Bootstrap ClassLoader</li></ul><p>负责加载在机器上安装的Java目录下的核心类。一旦JVM启动，那么首先会依托启动类加载器，去加载Java安装目录下的<code>lib</code>目录中的核心类库。</p><ul><li>扩展类加载器 Extension ClassLoader</li></ul><p>负责加载Java安装目录下<code>lib\ext</code>目录</p><ul><li>应用程序类加载器 Application ClassLoader</li></ul><p>负责加载<code>ClassPath</code>环境变量所指定的路径中的类，即自己写好的类</p><ul><li>自定义加载器</li></ul><p>可以自定义类加载器，去根据需求加载类</p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>JVM类加载器存在亲子层级结构，启动类加载器是最上层，扩展类加载器在第二层，应用程序类加载器在第三层，最后一程是自定义加载器。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12966419/1650333345396-b7eac5b3-8670-4c8c-89ed-9fafaf9ac629.png#clientId=ucd5f05b7-da21-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=370&id=ue5a25008&margin=%5Bobject%20Object%5D&name=image.png&originHeight=370&originWidth=262&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8073&status=done&style=none&taskId=ude39a97f-e7f6-457b-a0a7-b232b8e9de0&title=&width=262" alt="image.png"><br>双亲委派机制<br>假设应用程序类加载器需要加载一个类，会首先委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载。如果父类加载器在自己负责的范围内，没有找到这个类，就会下推加载权利给自己的子类加载器。<br>这样可以避免多层级的加载器结构重复加载某些类。</p><h1 id="JVM内存区域划分"><a href="#JVM内存区域划分" class="headerlink" title="JVM内存区域划分"></a>JVM内存区域划分</h1><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>JDK1.8之前，代表JVM中的一块区域，存放从<code>.class</code>文件加载进来的类，还要一些类似常量池的东西在这个区域。</p><p>JDK1.8之后，改名叫做<code>Metaspace</code>元数据空间，还是主要存放自己写的各种类相关的信息。</p><p><strong>Metaspace</strong><br>如果在代码里使用了类似反射的方式，JVM会动态去生成一些类放入Metaspace区域</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>每个线程有一个自己的程序计数器，记录当前这个线程目前执行到了哪一条字节码指令。</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>存放方法内部的局部变量的数据。调用执行任何方法时，会给方法创建栈帧，然后入栈。<br>每个线程有自己的Java虚拟机栈。如果线程执行了一个方法，就会对这个方法调用创建对应的一个栈帧。<br>栈帧里面有这个方法的局部变量表、操作数栈、动态链接、方法出口等东西。</p><h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p>存放代码中创建的各种对象。</p><h2 id="其他内存区域"><a href="#其他内存区域" class="headerlink" title="其他内存区域"></a>其他内存区域</h2><p>堆外内存</p><ul><li>底层API使用native方法调用底层程序的时候，会有线程对应的本地方法栈，存放各种native方法的局部变量表之类的信息</li><li>通过NIO中的allocateDirect这种API，在Java堆外分配内存空间，通过Java虚拟机的DirectByteBuffer来引用和操作堆外内存空间</li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12966419/1650335156451-524eeb6d-e291-4933-8f7b-3ef1e7269b01.png#clientId=ucd5f05b7-da21-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=416&id=ud98afa72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=416&originWidth=581&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21681&status=done&style=none&taskId=u47cde547-b04c-44e3-a5ff-9dbf62dcb82&title=&width=581" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Kafka</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReplicaManager</span> <span class="hljs-variable">replicaManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReplicaManager</span>();<br>        replicaManager.loadReplicasFromDisk();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReplicaManager</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> replicaCount;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadReplicasFromDisk</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">hasFinishedLoad</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">if</span>(isLocalDataCorrupt())&#123;&#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">isLocalDataCorrupt</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">isCorrupt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> isCorrupt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>JVM进程启动，加载Kafka类到内存，然后有一个main线程，开始执行Kafka中的main方法</li><li>main线程关联了一个程序计数器，线程执行到哪一行指令，就会记录到哪一行</li><li>main线程在执行main()方法的时候，会在main线程关联的Java虚拟机栈里面，压入一个main()方法的栈帧。</li><li>mian线程发现需要创建一个ReplicaManager类的实例对象，此时会加载ReplicaManager类到内存中。</li><li>然后创建一个ReplicaManager的对象实例分配在Java堆内存中，并且在mian()方法的栈帧里面的局部变量表引入<code>replicaManager</code>变量，让他引用ReplicaManager对象在Java堆内存中的地址。</li><li>main线程开始执行ReplicaManager对象中的方法，依次把自己执行到的方法的栈帧压入自己的Java虚拟机栈</li><li>执行完方法后，再把方法对应的栈帧从Java虚拟机栈里出栈</li></ol><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>只要启动一个JVM进程，就会自带一个垃圾回收的后台线程，会不断检测JVM堆内存中的各个实例对象。<br>如果这个实例对象没有任何一个方法的局部变量指向他，也没有任何一个类的静态变量，包括常量等地方指向他，那么垃圾回收线程就会把没人指向的实例对象给回收掉。从内存中清除，不在占用资源。</p><p>方法区的类回收的条件</p><ul><li>该类的所有实例对象已经从Java堆内存里被回收</li><li>加载这个类的ClassLoader已经被回收</li><li>对该类的Class对象没有任何应用</li></ul><h1 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a>JVM内存划分</h1><h2 id="分代模型"><a href="#分代模型" class="headerlink" title="分代模型"></a>分代模型</h2><ul><li>年轻代</li></ul><p>很快就要被回收的对象</p><ul><li>老年代</li></ul><p>长期存在的对象</p><ul><li>永久代</li></ul><p>方法区。存放一些类信息。</p><h2 id="垃圾回收流程"><a href="#垃圾回收流程" class="headerlink" title="垃圾回收流程"></a>垃圾回收流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Kafka</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReplicFetcher</span> <span class="hljs-variable">fetcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReplicFetcher</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        loadReplicasFromDisk();<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            loadReplicasFromRemote();<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadReplicasFromDisk</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ReplicaManager</span> <span class="hljs-variable">replicaManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReplicaManager</span>();<br>        replicaManager.load();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadReplicasFromRemote</span><span class="hljs-params">()</span>&#123;   <br>        fetcher.fetch();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>fetcher引用了ReplicFetcher对象，是长期需要驻留在内存中使用的。这个对象在年轻代停留后，最终会进入老年代。</p><ol><li>大部分的正常对象，都是优先在新生代分配内存。</li></ol><p>fetcher和replicaManager实例对象，都是分配在新生代里面。</p><ol start="2"><li>loadReplicasFromDisk()方法的栈帧出栈的时候，会导致没有任何局部变量应用replicaManager实例对象。当越来越多的这种对象快要占满新生代预分配的内存空间时，会触发一次新生代内存空间的垃圾回收。</li></ol><p>新生代内存的垃圾回收，称为<code>Minor GC</code>，也叫作<code>Young GC</code>，会尝试把新生代里面没有人引用的垃圾对象回收掉</p><ol start="3"><li>长期存活的对象会躲过多次垃圾回收。每垃圾回收一次，如果一个对象没有被回收掉，他的年龄就会增加1。</li></ol><p>fetcher由于是静态变量，所以长期持有，导致一直没有被回收掉。当他到达一定的年龄，会被转移到Java堆内存的老年代中。</p><ol start="4"><li>老年代的对象随着代码的运行，不再被人引用，达到一定条件也会进行垃圾回收。</li></ol><h2 id="内存相关参数"><a href="#内存相关参数" class="headerlink" title="内存相关参数"></a>内存相关参数</h2><ul><li>-Xms</li></ul><p>Java堆内存初始大小</p><ul><li>-Xmx</li></ul><p>Java堆内存的最大大小</p><ul><li>-Xmn</li></ul><p>Java堆内存中的新生代大小，根据扣除新生代，剩下的就是老年代内存大小</p><ul><li>-XX:PermiSize</li></ul><p>永久代初始大小</p><ul><li>-XX:MaxPermSize</li></ul><p>永久代最大大小</p><ul><li>-XX:MetaspaceSize</li></ul><p>元空间初始大小</p><ul><li>-XX:MaxMetaspaceSize</li></ul><p>元空间最大大小</p><ul><li>-Xss</li></ul><p>每个线程的栈内存大小</p><p>-Xms和-Xms，分别设置Java堆内存的刚开始的大小，以及允许扩张到的最大大小。<br>一般会设置成完全一样的大小，这个参数用来限定Java堆内存的总大小。</p><p>-Xmm，设置Java堆内存中的新生代大小。</p><p>-XX:PerSize和-XX:MaxPermSize，分别限定了永久代大小和永久代的最大大小。<br>通常也会设置成一样。一般设置几百MB够用。</p><p>-XX:MaxPermSize和-XX:MaxMetaspaceSize，在JDK1.8之后，永久代被元空间代替。</p><p>-Xss，限定了每个线程的栈内存大小。一般默认就是512KB-1MB。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12966419/1650351916701-e12a8853-b1d9-45cf-b7aa-5e26f0b7dc14.png#clientId=ucd5f05b7-da21-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=344&id=u57a1c73a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=344&originWidth=368&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9619&status=done&style=none&taskId=ucfe8876b-671b-4de2-9e56-60a6d3f7e9b&title=&width=368" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
